# YouTube Analyzer

A Python application that downloads YouTube videos and transcribes them using OpenAI's Whisper model. The application is built with a clean service-oriented architecture using dependency injection.

## Features

- **YouTube Video Download**: Download videos using yt-dlp with configurable quality settings
- **Audio Transcription**: Transcribe audio using Faster Whisper with support for multiple model sizes
- **Consistent File Naming**: All files use video IDs for predictable and consistent naming
- **Service Architecture**: Clean separation of concerns with proper dependency injection
- **Configuration Management**: Flexible configuration with environment variable support
- **Comprehensive Logging**: Structured logging using Loguru
- **Error Handling**: Robust error handling and recovery

## Architecture

The application follows a service-oriented architecture with the following components:

### Core Services

- **`YouTubeDownloadService`**: Handles YouTube video downloads using yt-dlp
- **`TranscriptionService`**: Manages audio transcription using Whisper
- **`ConfigService`**: Manages application configuration and settings
- **`YouTubeAnalyzer`**: Main orchestrator that coordinates download and transcription

### Design Patterns

- **Dependency Injection**: Services are injected into consumers for loose coupling
- **Interface Segregation**: Abstract base classes define service contracts
- **Factory Pattern**: `ServiceFactory` creates and configures service instances
- **Configuration Pattern**: Centralized configuration management with environment overrides

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd youtube-analyser
```

2. Install dependencies using uv:
```bash
uv sync
```

3. Activate the virtual environment:
```bash
source .venv/bin/activate
```

## Usage

### Basic Usage

```python
from services import ServiceFactory

# Create services using the factory
factory = ServiceFactory()
analyzer = factory.create_analyzer()

# Analyze a YouTube video (download + transcribe)
result = analyzer.analyze_youtube_video("3MZS5gNElZM")

if result['success']:
    print(f"Video: {result['video_file']}")
    print(f"Transcription: {result['transcription_file']}")
```

### Custom Configuration

```python
from services import ConfigService, ServiceFactory

# Create custom configuration
config = ConfigService()
config.set('download', 'default_output_path', './source-files/custom')
config.set('transcription', 'default_model_size', 'small')

# Create factory with custom config
factory = ServiceFactory(config)
analyzer = factory.create_analyzer()
```

### Individual Services

```python
from services import YouTubeDownloadService, TranscriptionService, YouTubeAnalyzer

# Create individual services
download_service = YouTubeDownloadService('./source-files/individual', 'best')
transcription_service = TranscriptionService('base', 'cpu')

# Create analyzer with custom services
analyzer = YouTubeAnalyzer(download_service, transcription_service)
```

### Environment Configuration

Set environment variables to override default settings:

```bash
export YT_OUTPUT_PATH="./source-files/env"
export WHISPER_MODEL_SIZE="tiny"
export WHISPER_DEVICE="cpu"
export LOG_LEVEL="DEBUG"
```

## File Organization

All processed files are stored in the `source-files` directory relative to the application root:

```
source-files/
├── 3MZS5gNElZM.mp4          # Downloaded video
├── 3MZS5gNElZM.txt          # Transcription
├── dQw4w9WgXcQ.mp4          # Another video
├── dQw4w9WgXcQ.txt          # Another transcription
└── custom/                   # Custom subdirectories
    └── example.mp4
```

## File Naming

All files generated by the application use the YouTube video ID for consistent and predictable naming:

- **Video files**: `source-files/{video_id}.mp4` (e.g., `source-files/3MZS5gNElZM.mp4`)
- **Transcription files**: `source-files/{video_id}.txt` (e.g., `source-files/3MZS5gNElZM.txt`)

This ensures that:
- Files are easily identifiable by their source video
- No conflicts with special characters in YouTube titles
- Consistent naming across different operating systems
- Easy to correlate files with their source videos
- Organized storage in dedicated source-files directory

## Configuration Options

### Download Settings
- `default_output_path`: Directory for downloaded videos (default: ".")
- `default_resolution`: Video quality (default: "best")
- `merge_output_format`: Output format (default: "mp4")

### Transcription Settings
- `default_model_size`: Whisper model size (tiny, base, small, medium, large)
- `device`: Processing device (cuda, cpu)
- `compute_type`: Computation precision (float16, float32)
- `beam_size`: Beam search size for transcription

### Logging Settings
- `level`: Log level (DEBUG, INFO, WARNING, ERROR)
- `format`: Log message format

## Examples

Run the example scripts to see different usage patterns:

```bash
python examples/basic_usage.py
```

## Service Interfaces

### IYouTubeDownloadService
```python
class IYouTubeDownloadService(ABC):
    @abstractmethod
    def download_video(self, video_id: str, output_path: str, resolution: str) -> str:
        """Download a YouTube video and return the file path."""
        pass
    
    @abstractmethod
    def get_video_info(self, video_id: str) -> dict:
        """Get video information without downloading."""
        pass
```

### ITranscriptionService
```python
class ITranscriptionService(ABC):
    @abstractmethod
    def transcribe_file(self, file_path: str, model_size: str) -> str:
        """Transcribe an audio/video file and return the output file path."""
        pass
    
    @abstractmethod
    def get_transcription_info(self, file_path: str) -> dict:
        """Get transcription information without saving to file."""
        pass
```

## Error Handling

The application includes comprehensive error handling:

- **Input Validation**: Checks for valid video IDs and file paths
- **Download Errors**: Handles network issues and invalid video IDs
- **Transcription Errors**: Manages model loading and processing failures
- **Configuration Errors**: Validates configuration values and environment variables

## Logging

The application uses Loguru for structured logging:

- **Configurable Levels**: Set log level via configuration or environment
- **Structured Output**: Consistent log format with timestamps and levels
- **Error Tracking**: Detailed error logging with context information

## Testing

The service architecture makes testing straightforward:

```python
# Mock services for testing
mock_download_service = Mock(spec=IYouTubeDownloadService)
mock_transcription_service = Mock(spec=ITranscriptionService)

# Create analyzer with mocks
analyzer = YouTubeAnalyzer(mock_download_service, mock_transcription_service)

# Test with mocked responses
mock_download_service.download_video.return_value = "test_video.mp4"
mock_transcription_service.transcribe_file.return_value = "test_transcript.txt"
```

## Dependencies

- **yt-dlp**: YouTube video downloading
- **faster-whisper**: Audio transcription
- **loguru**: Structured logging
- **ffmpeg-python**: Audio/video processing

## Contributing

1. Follow the existing service architecture patterns
2. Add proper error handling and logging
3. Include type hints and docstrings
4. Update tests for new functionality
5. Follow PEP 8 style guidelines

## License

[Add your license information here]
